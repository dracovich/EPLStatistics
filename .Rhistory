m.Manager,
1 as count
from     totalCombined as g
left join
managers as m
on m.Team=g.team
where g.Date<m.ToDate   AND
g.Date>m.FromDate")
test<-aggregate(count~X, data=withManagers,sum)
test2<-test[which(test$count>2),]
View(test3)
test3<-withManagers[which(withManagers$X==2274),]
View(test3)
View(managers)
withManagers<- sqldf("select  g.*,
m.Manager,
1 as count
from     totalCombined as g
left join
managers as m
on m.Team=g.team
where g.Date<m.ToDate   AND
g.Date>m.FromDate")
View(test2)
View(managers)
View(test3)
test<-aggregate(count~X, data=withManagers,sum)
test2<-test[which(test$count>2),]
test3<-withManagers[which(withManagers$X==2274),]
View(test)
library(zoo)
library(sqldf)
library(plyr)
library(reshape2)
library(ggplot2)
setwd("C:/Users/dracovich/Desktop/Data Science/Create data products")
## Load the cleanup functions
source(file="teamCleanup.R")
source(file="teamMerge.R")
source(file="teamStanding.R")
source(file="tableStanding.R")
## Download and clean data, only if this is first time running
## source("data-cleaning.R")
## Load the edited file and define the colClasses
col<-c("factor",rep("character",4),rep("numeric",5),"character",rep("numeric",16))
data<-read.csv("games_clean.csv")
## We have to reformat the date variable from a string to a date
## Upon looking at data however, we see that tehre are two formats in data, so we need to split data first
## Then format, and subsequently rejoin them with the same date format
dateLengthLong<-nchar(as.character(data$Date))>8
dateLengthShort<-nchar(as.character(data$Date))<=8
dateLong<-data[dateLengthLong,]
dateShort<-data[dateLengthShort,]
dateShort$Date<-as.Date(dateShort$Date, "%d/%m/%y")
dateLong$Date<-as.Date(dateLong$Date, "%d/%m/%Y")
data<-rbind(dateShort,dateLong)
## Incomplete dataset, missing half of 12-13 and nothing after that
seasons_wanted<-c("01-02",
"02-03",
"03-04",
"04-05",
"05-06",
"06-07",
"07-08",
"08-09",
"09-10",
"10-11",
"11-12")
selection_row<-data$season %in% seasons_wanted
data<-cbind(data,selection_row)
## Select the relevant seasons, and premier league (E0) only
data<-subset(data,selection_row==TRUE & Div=="E0")
## Need to rename since "AS" messes with the SQL syntax if its a variable name.
data<-rename(data,c("AS"="AwayShots", "HS"="HomeShots"))
## We cycle through all games in all seasons, and create a rolling mean of the previous
## 3 games for all variables, in order to get predictive variables.
for(k in seasons_wanted){
season_subset<-subset(data,season==k)
teams<-unique(season_subset$HomeTeam)
for (i in teams){
team_subset<-subset(season_subset,(HomeTeam==i | AwayTeam==i))
## Run the cleanup on data for team i
team_cleaned<-teamCleanup(i,team_subset)
## If it's the first team, initiate the data-frame, if not just append it
if(i==teams[1]){
combined<-team_cleaned
} else {
combined<-rbind(combined,team_cleaned)
}
}
cleanSeason<-season_subset[c(1,5,6,11)]
## Removing the first 5 games again (since they dont hvae rolling 5 data)
combinedClean<-as.data.frame(combined[complete.cases(combined$mGoals),])
## Calculate the standing of each team before each game measured (using previously defined functions)
indTeamStanding<-as.data.frame(apply(combinedClean[,c("season","Date","team")],1,function(x) teamStanding(x[1],x[2],x[3])))
names(indTeamStanding)[1]<-"standing"
combinedFinal<-cbind(combinedClean,indTeamStanding)
if(k==seasons_wanted[1]){
totalCombined<-combinedFinal
} else {
totalCombined<-rbind(totalCombined,combinedFinal)
}
}
## Load the manager data file
managers<-read.csv2("managers.csv",strip.white=TRUE)
managers$FromDate<-as.Date(managers$From, "%d-%m-%Y")
managers$ToDate<-as.Date(managers$To, "%d-%m-%Y")
## Merge managers onto the timestamps using SQL (not sure how easy this would be to do with R-code merging)
withManagers<- sqldf("select  g.*,
m.Manager,
1 as count
from     totalCombined as g
left join
managers as m
on m.Team=g.team
where g.Date<m.ToDate   AND
g.Date>m.FromDate")
### Next sttep: Sum up on X to find which ones are getting duplicated
test<-aggregate(count~X, data=withManagers,sum)
test2<-test[which(test$count>2),]
test3<-withManagers[which(withManagers$X==2274),]
View(test3)
withManagers<- sqldf("select  distinct
g.*,
m.Manager,
1 as count
from     totalCombined as g
left join
managers as m
on m.Team=g.team
where g.Date<m.ToDate   AND
g.Date>m.FromDate")
### Next sttep: Sum up on X to find which ones are getting duplicated
test<-aggregate(count~X, data=withManagers,sum)
test2<-test[which(test$count>2),]
test3<-withManagers[which(withManagers$X==2274),]
View(test3)
View(test2)
test3<-withManagers[which(withManagers$X==15403),]
View(test3)
View(managers)
managers<-read.csv2("managers.csv",strip.white=TRUE)
managers$FromDate<-as.Date(managers$From, "%d-%m-%Y")
managers$ToDate<-as.Date(managers$To, "%d-%m-%Y")
View(managers)
withManagers<- sqldf("select  distinct
g.*,
m.Manager,
1 as count
from     totalCombined as g
left join
managers as m
on m.Team=g.team
where g.Date<m.ToDate   AND
g.Date>m.FromDate")
### Next sttep: Sum up on X to find which ones are getting duplicated
test<-aggregate(count~X, data=withManagers,sum)
test2<-test[which(test$count>2),]
test3<-withManagers[which(withManagers$X==15403),]
View(test2)
View(test2)
test3<-withManagers[which(withManagers$X==17939),]
View(test3)
managers<-read.csv2("managers.csv",strip.white=TRUE)
managers$FromDate<-as.Date(managers$From, "%d-%m-%Y")
managers$ToDate<-as.Date(managers$To, "%d-%m-%Y")
## Merge managers onto the timestamps using SQL (not sure how easy this would be to do with R-code merging)
withManagers<- sqldf("select  distinct
g.*,
m.Manager,
1 as count
from     totalCombined as g
left join
managers as m
on m.Team=g.team
where g.Date<m.ToDate   AND
g.Date>m.FromDate")
### Next sttep: Sum up on X to find which ones are getting duplicated
test<-aggregate(count~X, data=withManagers,sum)
test2<-test[which(test$count>2),]
test2<-test[which(test$count==2),]
test3<-withManagers[which(withManagers$X==17939),]
test2<-test[which(test$count==1),]
test3<-withManagers[which(withManagers$X==17939),]
View(test2)
test3<-totalCombined[which(totalCombined$X==4235),]
View(test3)
test3<-withManagers[which(withManagers$X==4235),]
test4<-totalCombined[which(totalCombined$X==4235),]
View(test3)
View(test4)
managers<-read.csv2("managers.csv",strip.white=TRUE)
managers$FromDate<-as.Date(managers$From, "%d-%m-%Y")
managers$ToDate<-as.Date(managers$To, "%d-%m-%Y")
## Merge managers onto the timestamps using SQL (not sure how easy this would be to do with R-code merging)
withManagers<- sqldf("select  distinct
g.*,
m.Manager,
1 as count
from     totalCombined as g
left join
managers as m
on m.Team=g.team
where g.Date<m.ToDate   AND
g.Date>m.FromDate")
### Next sttep: Sum up on X to find which ones are getting duplicated
test<-aggregate(count~X, data=withManagers,sum)
test2<-test[which(test$count==1),]
View(withManagers)
View(totalCombined)
managers<-read.csv2("managers.csv",strip.white=TRUE)
managers$FromDate<-as.Date(managers$From, "%d-%m-%Y")
managers$ToDate<-as.Date(managers$To, "%d-%m-%Y")
## Merge managers onto the timestamps using SQL (not sure how easy this would be to do with R-code merging)
withManagers<- sqldf("select  distinct
g.*,
m.Manager,
1 as count
from     totalCombined as g
left join
managers as m
on m.Team=g.team
where g.Date<m.ToDate   AND
g.Date>m.FromDate")
test<-aggregate(count~X, data=withManagers,sum)
test2<-test[which(test$count==1),]
View(test2)
test3<-withManagers[which(withManagers$X==2087),]
test4<-totalCombined[which(totalCombined$X==2087),]
View(test4)
test3<-withManagers[which(withManagers$X==10255),]
test4<-totalCombined[which(totalCombined$X==10255),]
View(withManagers)
test<-merge(totalCombined,withManagers,by="X")
View(test)
### Next sttep: Sum up on X to find which ones are getting duplicated
test<-merge(totalCombined,withManagers,by.x="X",by.y="X")
test<-sqldf("select distinct
t.*,
m.Manager,
from  totalCombined as t
left join
withManagers as m
on t.X=m.X")
test<-sqldf("select distinct
t.*,
m.Manager
from  totalCombined as t
left join
withManagers as m
on t.X=m.X")
test<-sqldf("select distinct
t.*,
m.Manager
from  totalCombined as t
left join
withManagers as m
on t.X=m.X")
test5<-sqldf("select distinct
t.*,
m.Manager
from  totalCombined as t
left join
withManagers as m
on t.X=m.X")
View(totalCombined)
View(withManagers)
test5<-sqldf("select distinct
t.*,
m.Manager
from  totalCombined as t
left join
withManagers as m
on    t.X=m.X and
t.team=m.team" )
View(test5)
test5<-sqldf("select distinct
t.*,
m.Manager
from  totalCombined as t
left join
withManagers as m
on    t.X=m.X and
t.team=m.team
where manager='' " )
test5<-sqldf("select distinct
t.*,
m.Manager
from  totalCombined as t
left join
withManagers as m
on    t.X=m.X and
t.team=m.team
where Manager='' " )
test5<-sqldf("select distinct
t.*,
m.Manager
from  totalCombined as t
left join
withManagers as m
on    t.X=m.X and
t.team=m.team " )
test<-test5[where(test5$Manager==""),]
test<-test5[which(test5$Manager==""),]
View(totalCombined)
View(test5)
test<-test5[is.na(test5$Manager),]
View(test)
withManagers<- sqldf("select  distinct
g.*,
m.Manager,
1 as count
from     totalCombined as g
left join
managers as m
on m.Team=g.team
where g.Date<=m.ToDate   AND
g.Date>m.FromDate")
test5<-sqldf("select distinct
t.*,
m.Manager
from  totalCombined as t
left join
withManagers as m
on    t.X=m.X and
t.team=m.team " )
test<-test5[is.na(test5$Manager),]
View(test)
managers<-read.csv2("managers.csv",strip.white=TRUE)
managers$FromDate<-as.Date(managers$From, "%d-%m-%Y")
managers$ToDate<-as.Date(managers$To, "%d-%m-%Y")
## Merge managers onto the timestamps using SQL (not sure how easy this would be to do with R-code merging)
withManagers<- sqldf("select  distinct
g.*,
m.Manager,
1 as count
from     totalCombined as g
left join
managers as m
on m.Team=g.team
where g.Date<=m.ToDate   AND
g.Date>m.FromDate")
### Next sttep: Sum up on X to find which ones are getting duplicated
test5<-sqldf("select distinct
t.*,
m.Manager
from  totalCombined as t
left join
withManagers as m
on    t.X=m.X and
t.team=m.team " )
test<-test5[is.na(test5$Manager),]
View(test)
withManagers<- sqldf("select  distinct
g.*,
m.Manager,
1 as count
from     totalCombined as g
left join
managers as m
on m.Team=g.team
where g.Date<=m.ToDate   AND
g.Date>m.FromDate")
### Next sttep: Sum up on X to find which ones are getting duplicated
test5<-sqldf("select distinct
t.*,
m.Manager
from  totalCombined as t
left join
withManagers as m
on    t.X=m.X and
t.team=m.team " )
test<-test5[is.na(test5$Manager),]
View(test)
test<-test5[is.na(test5$Manager),]
test5<-sqldf("select distinct
t.*,
m.Manager
from  totalCombined as t
left join
withManagers as m
on    t.X=m.X and
t.team=m.team " )
test<-test5[is.na(test5$Manager),]
View(test)
library(zoo)
library(sqldf)
library(plyr)
library(reshape2)
library(ggplot2)
setwd("C:/Users/dracovich/Desktop/Data Science/Create data products")
## Load the cleanup functions
source(file="teamCleanup.R")
source(file="teamMerge.R")
source(file="teamStanding.R")
source(file="tableStanding.R")
## Download and clean data, only if this is first time running
## source("data-cleaning.R")
## Load the edited file and define the colClasses
col<-c("factor",rep("character",4),rep("numeric",5),"character",rep("numeric",16))
data<-read.csv("games_clean.csv")
## We have to reformat the date variable from a string to a date
## Upon looking at data however, we see that tehre are two formats in data, so we need to split data first
## Then format, and subsequently rejoin them with the same date format
dateLengthLong<-nchar(as.character(data$Date))>8
dateLengthShort<-nchar(as.character(data$Date))<=8
dateLong<-data[dateLengthLong,]
dateShort<-data[dateLengthShort,]
dateShort$Date<-as.Date(dateShort$Date, "%d/%m/%y")
dateLong$Date<-as.Date(dateLong$Date, "%d/%m/%Y")
data<-rbind(dateShort,dateLong)
## Incomplete dataset, missing half of 12-13 and nothing after that
seasons_wanted<-c("01-02",
"02-03",
"03-04",
"04-05",
"05-06",
"06-07",
"07-08",
"08-09",
"09-10",
"10-11",
"11-12")
selection_row<-data$season %in% seasons_wanted
data<-cbind(data,selection_row)
## Select the relevant seasons, and premier league (E0) only
data<-subset(data,selection_row==TRUE & Div=="E0")
## Need to rename since "AS" messes with the SQL syntax if its a variable name.
data<-rename(data,c("AS"="AwayShots", "HS"="HomeShots"))
## We cycle through all games in all seasons, and create a rolling mean of the previous
## 3 games for all variables, in order to get predictive variables.
for(k in seasons_wanted){
season_subset<-subset(data,season==k)
teams<-unique(season_subset$HomeTeam)
for (i in teams){
team_subset<-subset(season_subset,(HomeTeam==i | AwayTeam==i))
## Run the cleanup on data for team i
team_cleaned<-teamCleanup(i,team_subset)
## If it's the first team, initiate the data-frame, if not just append it
if(i==teams[1]){
combined<-team_cleaned
} else {
combined<-rbind(combined,team_cleaned)
}
}
cleanSeason<-season_subset[c(1,5,6,11)]
## Removing the first 5 games again (since they dont hvae rolling 5 data)
combinedClean<-as.data.frame(combined[complete.cases(combined$mGoals),])
## Calculate the standing of each team before each game measured (using previously defined functions)
indTeamStanding<-as.data.frame(apply(combinedClean[,c("season","Date","team")],1,function(x) teamStanding(x[1],x[2],x[3])))
names(indTeamStanding)[1]<-"standing"
combinedFinal<-cbind(combinedClean,indTeamStanding)
if(k==seasons_wanted[1]){
totalCombined<-combinedFinal
} else {
totalCombined<-rbind(totalCombined,combinedFinal)
}
}
## Load the manager data file
## All caretaker managers are designed as "Caretaker manager", and if there was an overlap in periods, the new managers is
## given priority (since only one person can manage at a time in this analysis).
## A few times thereÂ¨s a gap in managers data, where noone seems to be in charge. In those cases the incoming manager
## gets the games, since that usually means that they were caretaker first, then took over.
managers<-read.csv2("managers.csv",strip.white=TRUE)
managers$FromDate<-as.Date(managers$From, "%d-%m-%Y")
managers$ToDate<-as.Date(managers$To, "%d-%m-%Y")
## Merge managers onto the timestamps using SQL (not sure how easy this would be to do with R-code merging)
withManagers<- sqldf("select  distinct
g.*,
m.Manager,
1 as count
from     totalCombined as g
left join
managers as m
on m.Team=g.team
where g.Date<=m.ToDate   AND
g.Date>m.FromDate")
### Next sttep: Sum up on X to find which ones are getting duplicated
test5<-sqldf("select distinct
t.*,
m.Manager
from  totalCombined as t
left join
withManagers as m
on    t.X=m.X and
t.team=m.team " )
test<-test5[is.na(test5$Manager),]
teamWanted<-withManagers[which(withManagers$team=="Chelsea"),]
ggplot(data=teamWanted, aes(x=Date, y=mShotsOnTarget)) +
geom_point(aes(colour=Manager, group=Manager)) +
stat_smooth(method="loess")
ggplot(data=teamWanted, aes(x=Date, y=mShotsOnTarget)) +
geom_point(aes(colour=Manager, group=Manager))
teamWanted<-withManagers[which(withManagers$team=="Newcastle"),]
ggplot(data=teamWanted, aes(x=Date, y=mShotsOnTarget)) +
geom_point(aes(colour=Manager, group=Manager))
ggplot(data=teamWanted, aes(x=Date, y=standing)) +
geom_point(aes(colour=Manager, group=Manager))
ggplot(data=teamWanted, aes(x=Date, y=mFouls)) +
geom_point(aes(colour=Manager, group=Manager))
teamWanted<-withManagers[which(withManagers$team=="Stoke"),]
ggplot(data=teamWanted, aes(x=Date, y=mFouls)) +
geom_point(aes(colour=Manager, group=Manager))
teamWanted<-withManagers[which(withManagers$team=="Chelsea"),]
ggplot(data=teamWanted, aes(x=Date, y=mFouls)) +
geom_point(aes(colour=Manager, group=Manager))
ggplot(data=teamWanted, aes(x=Date, y=mCorners)) +
geom_point(aes(colour=Manager, group=Manager))
teamWanted<-withManagers[which(withManagers$team=="Newcastle"),]
ggplot(data=teamWanted, aes(x=Date, y=mShotsOnTarget)) +
geom_point(aes(colour=Manager, group=Manager)) +
stat_smooth(method="loess")
